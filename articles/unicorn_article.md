---
title: "Q.クローラー修正時にunicornの再起動が必要ない理由を答えよ"
emoji: "🤔"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Rails","unicorn"]
published: false
---

## Answer

クローラーのコードとアプリケーションサーバーであるunicornが独立しているため

## 執筆動機

タイトルの疑問は昨年の秋頃から持ち始めたものの、
色々なことを言い訳にして特に調べずにいました。

しかしながら、時間が過ぎるにつれて自分がリリース時期を決定したり、
自力で保守運用をする必要が出てきたため、自分で調べることにしました。

## unicornとは何か？

Answerのところでunicornがアプリケーションサーバーであると書きました。
アプリケーションサーバーはWebアプリケーションを支える技術の1つである、
Web3層アーキテクチャの1要素です。

Web3層アーキテクチャ3層構造

- WEBサーバー：クライアントからリクエストを受け取り、WEBアプリケーション処理を渡す(例: Apache/Nginx...etc)
- アプリケーションサーバー：WEBアプリケーションの処理を行う(例: Unicorn/Puma/Passenger/gunicorn...etc)
- DBサーバー：アプリケーションサーバーからのデータの保存や更新、削除をする

## 何故unicornが必要になるのか？

ローカルの開発環境で開発する際にはunicornは必要ありませんが、
本番環境では必要になります。
具体的には
WEBアプリケーションの構成は開発と本番で次のように異なっています。

この理由はリクエストの数です。
開発環境と異なり、本番環境では複数のリクエストが同時に来ることが想定されます。
このため、ブラウザのリクエストからのリクエストを受けるWEBサーバーを配置し、
WEBアプリケーションはそれらのWEBサーバーの裏で動作させます。

なお、Rubyの場合、RackというWEBフレームワークとWEBサーバーを接続させるインターフェースがあります。
前段にワーカープロセスを起動するWEBサーバーを置いて、
その裏側をRackで接続し、パフォーマンスを上げる構成がよく取られます。

## unicornはどのように動作するのか

unicornがどのように動作するのかを
Ruby on Railsで開発したWEBアプリケーションを起動させるところから見ていきます。

1.プロセスの生成:
アプリケーションが起動する際には、アプリケーションサーバーが新しいプロセスを生成します。
このプロセスはオペレーティングシステムから独立したメモリ空間を持ちます。

2.初期化コードの実行:
プロセスが起動されると、Railsはその初期化コードを実行します。

3.コードの読み込み:
この初期化の過程で、必要なライブラリやGem、アプリケーションのコード（モデル、コントローラ、ヘルパーなど）がメモリ上に読み込まれます。これにより、リクエストの処理中に毎回ディスクからコードを読み込む必要がなくなり、応答速度が向上します。

4.ワーカープロセス/スレッドの生成:
1で生成されたプロセスをフォークして複数のワーカー（子）プロセスが生成されます。この時点で前回起動時のRailsアプリケーションの状態（メモリ上のコードやデータ）はすべて破棄され、新しくロードされたコードや設定が有効になります。

この段階で回答に必要な知識が揃いました。
unicornが初期化される際に、アプリケーションコードが読み込まれてクライアントからのリクエストを受け付ける準備が整います。
したがってコードを変更しただけではリクエストで返却される内容は変わらず、
unicornを再起動して初期化を行う必要があります。

## クローラー動作時の挙動

回答は出ましたが、クローラーの動作時にはどのような手順を踏むのかが
気になったので調べてみました。
今回はcronでRubyで作成したクローラーを定期実行することを想定しています。
cronが起動するところから見ていきます。

1.cronの起動:

システムが起動すると、cronデーモンも自動的に起動します。
cronデーモンは、指定された時間にジョブを実行するためのバックグラウンドプロセスです。

2.スケジュールの確認:

cronは、特定の間隔でcrontabファイルの内容をチェックし、指定された時間にジョブを実行するためのスケジュールを決定します。

3.クローラースクリプトの起動:

ジョブの実行時刻が来ると、cronは新しい子プロセスをフォークし、そのプロセス内でクローラースクリプトを実行します。
このとき、Rubyインタープリタが起動し、指定されたスクリプトファイルを実行します。

4.終了:

スクリプトの全ての行が実行されると、プロセスは終了します。
子プロセスも終了するため、このプロセスの占有していたメモリやその他のリソースはOSによって解放されます。

## 実演

## 補題①：unicornとpumaの違い

Unicorn:pre-working型のアプリケーションサーバー。
マスタープロセスが複数のワーカープロセスを生成し、各リクエストをワーカープロセスに振り分けて処理を行います。

Puma:スレッドベースのアプリケーションサーバー。
マルチスレッドで動作し、プロセスを増やす必要がないため、
リソースが少ない中でも効率的にリクエストを増やすことが可能になります。

## 補題②：プロセスとスレッドの違い

プロセス： オペレーティングシステムの下で実行される独立したプログラムのインスタンス。
           それぞれのプロセスは独立したメモリ空間を持ちますが、
           起動時に読み込まれたコードやライブラリは共有されます。
スレッド： プロセス内の実行単位。
           そのプロセスのメモリ空間を共有します。
           したがって、同一のコードやライブラリを使用します。

| 項目               | スレッド                                 | プロセス                                 |
|-------------------|----------------------------------------|----------------------------------------|
| **定義**            | プロセス内の実行単位。                 | オペレーティングシステムの下で実行される独立したプログラムのインスタンス。 |
| **メモリとリソース** | 同じプロセス内のメモリ空間、コード、データを共有。独自のレジスタとスタックを持つ。 | 独自のメモリ空間、コード、データ、およびシステムリソースを持つ。 |
| **開始と終了**       | 高速。                                | 比較的遅い。                            |
| **通信**            | 共有メモリを使用し効率的。               | IPCを使用し、オーバーヘッドが伴う。          |
| **オーバーヘッド**    | コンテキストスイッチのオーバーヘッドが少ない。 | コンテキストスイッチのオーバーヘッドが多い。  |
| **障害の影響**       | 1つのスレッドの障害が他のスレッドに影響する可能性がある。 | 1つのプロセスの障害が他のプロセスに影響しない。 |
| **独立性**          | リソースの共有により調整や同期が必要。     | 独立して動作し、他のプロセスの動作に影響を与えることは少ない。 |

## 参考文献、記事
[Pumaの本当の力を引き出す](https://qiita.com/ykyk1218/items/0ca7f1fa449b41fe1fea)
